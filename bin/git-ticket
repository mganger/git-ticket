#!/usr/bin/python2

import yaml
from hashlib import sha256
import tempfile
import traceback
import sys
args = sys.argv[1:]
exit = sys.exit
from git import Repo
import os
join = os.path.join

repo = Repo(os.getcwd())

commit_msg=\
"""title: 
assignee: 
start-date: 
due-date: 
type: 
state: 
comments: 
"""

import json
import re

#shameless copy paste from json/decoder.py
FLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL
WHITESPACE = re.compile(r'[ \t\n\r]*', FLAGS)

class ConcatJSONDecoder(json.JSONDecoder):
    def decode(self, s, _w=WHITESPACE.match):
        s_len = len(s)

        objs = []
        end = 0
        while end != s_len:
            obj, end = self.raw_decode(s, idx=_w(s, end).end())
            end = _w(s, end).end()
            objs.append(obj)
        return objs


arg   = ''
param = ''
try:
	arg   = args[0]
	param = args[1]
except: pass

def get_ticket(string):
	pass
	#check for ticket
	#return fully qualified hash

if arg  == 'init':
	#Use project name
	assert param != '', 'git-ticket init <project-name>'

	#Create new branch with name ticket-PROJECT
	project = param.upper()
	print project

	#SHA is empty commit
	#TODO assert project doesn't already exist
	try:
		past_branch = repo.head.reference
		os.system("git symbolic-ref HEAD refs/heads/ticket-{}".format(project))
		os.system("git clean -fdx")
		os.system("git reset")
		open(project, 'w').write(project+'\n')
		os.system("git add {}".format(project))
		os.system('git commit -m "Inital commit of ticket-{} branch"'.format(project))
	except:
		print traceback.format_exc()
	finally:
		repo.head.reference = past_branch
		repo.git.reset()
		

	#Touch '.ticket' and do the initial commit
	if not os.path.exists('.git/.ticket'):
		open('.git/.ticket', 'a').close()

	#TODO add commit hook to folder (.git/hooks/commit-msg)

elif arg == 'project':
	pass
	#Check for project branch
	#Write the project to .git/current_project
	open('.git/current_project','w').write(param.upper())

elif arg == 'new':
	#Check that there is a project in the .git folder

	#Get a tmp file and do the whole git commit thing
	#Parse the ticket for (use yaml):
	#	title
	#	assignee       (default current)
	#	start-date     (default today)
	#	due-date       (optional)
	#	type           (default feature, else hotfix, support)
	#	state          (default open)
	#	comments
	info = []
	with tempfile.NamedTemporaryFile() as msg:
		msg.write(commit_msg)
		msg.seek(0)
		os.system("vim {}".format(msg.name))
		msg.seek(0)
		info = yaml.safe_load(msg)

	if info['title'] is None:
		print 'Abort new ticket'
		exit(1)

	if info['type'] not in {'feature', 'hotfix', 'release', 'support'}:
		print 'Invalid type'
		exit(2)

	info['hash'] = sha256(info['title']).hexdigest()

	project = open('.git/current_project').read().strip()
	project_branch = 'ticket-'+project

	#Save the file to tickets directory
	b_current = repo.active_branch
	repo.git.checkout(project_branch)
	with open('.tickets', 'a') as tickets:
		yaml.dump(info, tickets)
	repo.index.add(['.tickets'])
	repo.index.commit('Added [{}-{}]'.format(project, info['hash'][:6]))
	repo.git.checkout(b_current)


elif arg == 'list':
	pass
	#Make a tree of all open tickets
	#	Show the hash as well as the number
	#all:
	#	show all tickets (open, closed, invalid, hold, in-progress)
	#open:
	#closed:
	#invalid:
	#in-progress

elif arg == 'start':
	pass
	#Check for ticket; if it is a super, and there are open/in-progress tickets below it, close
	#Create a new branch like: git-flow feature start PROJECT-HASH-title-in-lowercase
	#set current ticket to in-progress

elif arg == 'finish':
	pass
	#check for ticket using the branch name
	#run git-flow feature finish
	#mark ticket as closed

elif arg == 'state':
	pass
	#check for ticket
	#allow open, closed, invalid, hold, in-progress
else:
	pass
	#show default message
