#!/usr/bin/python2

import re
import yaml
from hashlib import sha256
import tempfile
import traceback
import sys
args = sys.argv[1:]
exit = sys.exit
from git import Repo
import os
import json
join = os.path.join

repo = Repo(os.getcwd())

commit_msg=\
"""title:      
type:       
assignee:   
start-date: 
due-date:   
state:      
comments:   
"""

arg   = None
param = None
try:
	arg   = args[0]
	param = args[1]
except: pass

def get_tickets():
	with open('.ticket') as file:
		return json.load(file)
def write_tickets(obj):
	with open('.ticket','w') as file:
		json.dump(obj,file)
def project():
	with open('.git/current_project') as file:
		return file.read().strip()
def project_branch():
	return 'ticket-'+project()
def add_file(*names):
	repo.index.add(names)
def commit(string):
	repo.index.commit(string)

def get_ticket(tickets,string):
	if param == '':
		print 'Enter a ticket id or hash'
		exit(4)

	#if its an id:
	try:
		return tickets[int(param)]
		
	except:
		#try to find it by hash
		for tick in tickets:
			if param in tick['hash']:
				return tick

	if ticket == None:
		print "Id or hash not valid"
		exit(3)

def print_ticket(ticket):
	print_ticket_fields(id='', hash=ticket['hash'], state=ticket['state'], assignee=ticket['assignee'], due=ticket['due'], title=ticket['title'])
def print_ticket_fields(id, hash, state, assignee, due, title):
	print "{:<8} {:<10} {:<15} {:<15} {:<15}  {}".format(id,hash,state,assignee,due,title)


def mark_state(ticket, state, tickets):
	index = tickets.index(ticket)
	tickets[index]['state'] = state
	write_tickets(tickets)
	add_file('.ticket')


def checkout(name,this_repo=repo):
	b_current = this_repo.active_branch
	repo.git.checkout(name)
	return b_current

if arg  == 'init':
	#Use project name
	assert param != '', 'git-ticket init <project-name>'

	#Create new branch with name ticket-PROJECT
	project = param.upper()
	print project

	#SHA is empty commit
	#TODO assert project doesn't already exist
	try:
		past_branch = repo.head.reference
		os.system("git symbolic-ref HEAD refs/heads/ticket-{}".format(project))
		os.system("git clean -fdx")
		os.system("git reset")
		open(project, 'w').write(project+'\n')
		with open('.ticket', 'w') as file:
			yaml.dump([],file)
		os.system("git add {} .ticket".format(project))
		os.system('git commit -m "Inital commit of ticket-{} branch"'.format(project))
	except:
		print traceback.format_exc()
	finally:
		repo.head.reference = past_branch
		repo.git.reset()
		

	#Touch '.ticket' and do the initial commit
	if not os.path.exists('.git/.ticket'):
		open('.git/.ticket', 'a').close()

	os.system('git-ticket project {}'.format(project))

	#TODO add commit hook to folder (.git/hooks/commit-msg)

elif arg == 'project':
	if param == None:
		print 'git project <project-name>'
	#Check for project branch
	#Write the project to .git/current_project
	open('.git/current_project','w').write(param.upper())

elif arg == 'new':
	#Check that there is a project in the .git folder

	#Get a tmp file and do the whole git commit thing
	#Parse the ticket for (use yaml):
	#	title
	#	assignee       (default current)
	#	start-date     (default today)
	#	due-date       (optional)
	#	type           (default feature, else hotfix, support)
	#	state          (default open)
	#	comments
	info = []
	with tempfile.NamedTemporaryFile() as msg:
		msg.write(commit_msg)
		msg.seek(0)
		os.system("vim {}".format(msg.name))
		msg.seek(0)
		info = yaml.safe_load(msg)
	#defaults
	if info['state'] is None:
		info['state'] = 'open'


	#Error checking
	if info['title'] is None:
		print 'Abort new ticket'
		exit(1)
	if info['type'] not in {'feature', 'hotfix', 'release', 'support'}:
		print 'Invalid type'
		exit(2)
	if info['state'] not in {'open', 'closed', 'in-progress', 'invalid', 'hold'}:
		print 'Invalid state'

	#Hash
	info['hash'] = sha256(info['title']).hexdigest()

	#Change branches
	branch = checkout(name=project_branch())

	#Load current tickets from file
	ticks = get_tickets()

	for ticket in ticks:
		 if ticket['hash'] == info['hash']:
			print 'Ticket already exists'
			exit(1)

	ticks.append(info)

	#Save the file to tickets directory
	write_tickets(ticks)

	repo.index.add(['.ticket'])
	repo.index.commit('Added [{}-{}]'.format(project(), info['hash'][:6]))
	checkout(name=branch)

	#show the ticket
	print_ticket(ticket)


elif arg == 'list':
	branch = checkout(name=project_branch())

	allowed = ['open', 'in-progress']

	if param is not None:
		allowed = args[1:]


	print_ticket_fields('id','hash','state','assignee','due','title')
	print "-"*75

	for i,tick in enumerate(get_tickets()):
		if tick['state'] in allowed:
			print_ticket(tick)

	#Make a tree of all open tickets
	#	Show the hash as well as the number
	#all:
	#	show all tickets (open, closed, invalid, hold, in-progress)
	#open:
	#closed:
	#invalid:
	#in-progress
	checkout(name=branch)

elif arg == 'start':
	#Check for ticket
	branch = checkout(project_branch())

	tickets = get_tickets()
	ticket  = get_ticket(tickets,param)


	#Create a new branch like: git-flow feature start PROJECT-HASH-title-in-lowercase
	short_hash = str(ticket['hash'][:6])
	type_name  = str(ticket['type'])
	title      = re.sub(r'\s+','-',str(ticket['title']).lower())


	#set current ticket to in-progress
	mark_state(ticket, 'in-progress', tickets)
	commit('Started branch for [{}]'.format(ticket['hash'][:6]))

	os.system("git flow {} start {}-{}-{}".format(type_name,project(),short_hash,title))

elif arg == 'finish':
	branch = checkout(project_branch())
	tickets = get_tickets()
	ticket  = get_ticket(tickets,param)

	short_hash = str(ticket['hash'][:6])
	type_name  = str(ticket['type'])
	title      = re.sub(r'\s+','-',str(ticket['title']).lower())

	#mark ticket as closed
	mark_state(ticket, 'closed', tickets)
	commit('Finished branch for [{}]'.format(ticket['hash'][:6]))

	os.system("git flow {} finish {}-{}-{}".format(type_name,project(),short_hash,title))

elif arg in {'closed', 'invalid', 'open', 'in-progress'}:
	branch = checkout(project_branch())
	tickets = get_tickets()
	ticket  = get_ticket(tickets, param)

	mark_state(ticket, arg, tickets)
	commit('Marked [{}] as {}'.format(ticket['hash'][:6], arg))
	checkout(branch)

else:
	pass
	#show default message
