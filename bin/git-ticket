#!/usr/bin/python2

import re
import yaml
from hashlib import sha256
import tempfile
import subprocess
import os
import json
import gitticket as gt



if gt.command  == 'init':
	repo = gt.active_repo
	#Use project name
	assert gt.subject[0] != '', 'git-ticket init <project-name>'

	#Create new branch with name ticket-PROJECT
	project = gt.subject[0].upper()

	#SHA is empty commit
	#TODO assert project doesn't already exist
	with open(os.devnull, 'wb') as devnull:
		try:
			past_branch = gt.current_branch

			subprocess.check_call(["git checkout --orphan ticket-{}"].format(project),stdout=devnull,stderr=subprocess.STDOUT)
			os.system("git clean -fdx")
			os.system("git reset")

			open(project, 'w').write(project+'\n').close()
			with open('.ticket', 'w') as file:
				json.dump([],file)

			os.system("git add {} .ticket".format(project))
			os.system('git commit -m "Inital commit of ticket-{} branch"'.format(project))
			os.system('git-ticket project {}'.format(project))

			print "Initialized project {}".format(project)

		except:
			print "Couldn't initialize branch. Does it already exist?"
		finally:
			try: subprocess.check_call(["git checkout {}".format(past_branch)], stdout=devnull)
			except: pass
			#TODO add commit hook to folder (.git/hooks/commit-msg)
			gt.exit(0)


if gt.command == 'project':
	if gt.subject[0] == None:
		print 'git project <project-name>'
	#Check for project branch
	#Write the project to .git/current_project
	gt.open_in_dir('.git/current_project','w').write(gt.subject[0].upper())

elif gt.command == 'new':
	#Get a tmp file and do the whole git commit thing
	#Parse the ticket for (use yaml):
	#	title
	#	assignee       (default current)
	#	start-date     (default today)
	#	due-date       (optional)
	#	type           (default feature, else hotfix, support)
	#	state          (default open)
	#	comments
	info = []
	with tempfile.NamedTemporaryFile() as msg:
		msg.write(gt.commit_msg)
		msg.seek(0)
		os.system("vim {}".format(msg.name))
		msg.seek(0)
		info = yaml.safe_load(msg)
	#defaults
	if info['state'] is None:
		info['state'] = 'open'


	#Error checking
	if info['title'] is None:
		print 'Abort new ticket'
		exit(1)
	if info['type'] not in {'feature', 'hotfix', 'release', 'support'}:
		print 'Invalid type'
		exit(2)
	if info['state'] not in {'open', 'closed', 'in-progress', 'invalid', 'hold'}:
		print 'Invalid state'

	#Hash
	info['hash'] = sha256(info['title']).hexdigest()

	#Change branches

	#Load current tickets from file
	ticks = gt.get_tickets()

	for ticket in ticks:
		 if ticket['hash'] == info['hash']:
			print 'Ticket already exists'
			exit(1)

	ticks.append(info)

	#Save the file to tickets directory
	gt.write_tickets(ticks)

	repo.index.add(['.ticket'])
	repo.index.commit('Added [{}-{}]'.format(project(), info['hash'][:6]))
	gt.push()

	#show the ticket
	gt.print_ticket_header()
	gt.print_ticket(info)


elif gt.command == 'list':

	subs = gt.subject
	allowed = subs[:1] if len(subs) == 1 else subs if subs and set(gt.verb) == {'and'} else ['open', 'in-progress']

	gt.print_ticket_header()

	for i,tick in enumerate(gt.get_tickets()):
		if tick['state'] in allowed or 'all' in allowed:
			gt.print_ticket(tick,i)

	#Make a tree of all open tickets
	#Make this deplist
	#	Show the hash as well as the number
	#all:
	#	show all tickets (open, closed, invalid, hold, in-progress)
	#open:
	#closed:
	#invalid:
	#in-progress

elif gt.command == 'start':
	try:
		#Check for ticket
		tickets = gt.get_tickets()
		ticket  = gt.get_ticket(tickets,gt.subject[0])

		#Check to see if we want to stash changes and pop them later
		stashed = None
		try:
			stashed = gt.verb[0]
			subprocess.check_call(['git','stash','save'])
		except: pass


		#Create a new branch like: git-flow feature start PROJECT-HASH-title-in-lowercase
		short_hash = str(ticket['hash'][:6])
		type_name  = str(ticket['type'])
		title      = re.sub(r'\s+','-',str(ticket['title']).lower())


		#set current ticket to in-progress
		gt.mark_state(ticket, 'in-progress', tickets)
		gt.commit('Started branch for [{}]'.format(ticket['hash'][:6]))
		gt.push()

		os.system("git flow {} start {}-{}-{}".format(type_name,project(),short_hash,title))

		if stashed: subprocess.check_call(['git','stash','pop'])
	except:
		print "Cannot start ticket branch. If there are current changes, you may want to stash them first (or run git ticket start 3 stash)"

elif gt.command == 'finish':
	tickets = gt.get_tickets()
	ticket  = gt.get_ticket(tickets,gt.subject[0])

	short_hash = str(ticket['hash'][:6])
	type_name  = str(ticket['type'])
	title      = re.sub(r'\s+','-',str(ticket['title']).lower())

	#mark ticket as closed
	gt.mark_state(ticket, 'closed', tickets)
	gt.commit('Finished branch for [{}]'.format(ticket['hash'][:6]))
	gt.push()

	os.system("git flow {} finish {}-{}-{}".format(type_name,project(),short_hash,title))

elif gt.command in {'closed', 'invalid', 'open', 'in-progress'}:
	tickets = gt.get_tickets()
	ticket  = gt.get_ticket(tickets, gt.subject[0])

	gt.mark_state(ticket, gt.command, tickets)
	gt.commit('Marked [{}] as {}'.format(ticket['hash'][:6], gt.command))
	gt.push()

elif gt.command == 'show':
	tickets = gt.get_tickets()
	try:
		ticks_to_print = [gt.get_ticket(tickets, sub) for sub in gt.subject]
		gt.print_ticket_header()
		for ticket in ticks_to_print: gt.print_ticket(ticket)
	except:
		#show current ticket
		try:
			branch_name = gt.active_repo.active_branch.name
			match = re.search(r'\w+/\w+-(\w+)', branch_name)
			ticket = gt.get_ticket(tickets, match.group(1))
			gt.print_ticket_header()
			gt.print_ticket(ticket)
		except:
			print 'Not on a ticket branch'

else:
	print "git-ticket"
